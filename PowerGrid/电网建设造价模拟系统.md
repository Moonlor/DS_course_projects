# 数据结构课程设计 项目说明文档

>  #### 电网建设造价模拟系统
>
>  李坤
>
>  1553321



1. **项目介绍**

   - 假设一个城市有n个小区，要实现n个小区之间的电网都能够相互接通，构造这个城市n个小区之间的电网，使总工程造价最低。请设计一个能够满足要求的造价方案。
   - 在每个小区之间都可以设置一条电网线路，都要付出相应的经济代价。n个小区之间最多可以有n（n-1）/2条线路，选择其中的n-1条使总的耗费最少。

2. **整体描述**

   - 在最节省经费的前提下建立电网，此问题本质上是一个求最小生成树的问题，本程序利用Prim算法来实现求解的过程。

   - 运行环境：

     exe可执行文件：带有图形驱动的windows平台

     经过测试，源码也可在Unix平台（如MacOS）上正常编译并运行

   - 代码托管平台：Github

     ​

3. **系统设计**

   - **算法设计**：Prim算法本质上就是利用了贪心思想，随机选取一顶点作为起点，加入到集合U，接着找到与其关联的最小权值的边，该边上的另一个点也加入到U，接着再从U中的两个点出发继续向外找最小权值的边，找到后再加入第三个点，就这样重复下去。因为每次都是找最小值，所以当所有点都被加入U时，最小生成树也就被确定了。

   - **优化**：在Prim算法的实现上，没有采用传统的堆实现，而是利用三个辅助数组进行搜索。

   - **流程说明**：

     ![img](https://61mon.com/images/illustrations/Prim/1.png)

     - 随机选一起点，假如为 0，`low_cost[i]`表示以 i 为终点的边的权值。其过程描述如下：

       | 步骤    | low_cost[1] | low_cost[2] | low_cost[3] | low_cost[4] | 已找到的集合       |
       | ----- | ----------- | ----------- | ----------- | ----------- | ------------ |
       | 第 1 步 | 8           | 3           | 2           | +∞          | {3}          |
       | 第 2 步 | 3           | 3           | ×           | 5           | {3, 1}       |
       | 第 3 步 | ×           | 3           | ×           | 5           | {3, 1, 2}    |
       | 第 4 步 | ×           | ×           | ×           | 1           | {3, 1, 2, 4} |
       | 第 5 步 | ×           | ×           | ×           | ×           | {3, 1, 2, 4} |

     - 第 1 步：从起点 0 开始，找到与其邻接的点：1，2，3，更新`low_cost[]`数组，因 0 不与 4 邻接，故`low_cost[4]`为正无穷。在`low_cost[]`中找到最小值，其顶点为 3，即此时已找到最小生成树中的一条边：`0→3`。

     - 第 2 步：从 3 开始，继续更新`low_cost[]`数组：3 与 1 邻接，因`3→1`比`low_cost[1]`小，故更新`low_cost[1]`为 3；3 与 2 邻接，因`3→2`比`low_cost[2]`大，故不更新`low_cost[2]` ；3 与 4 邻接，因`3→4`比`low_cost[4]`小，故更新`low_cost[4]`为 5。在`low_cost[]`中找到最小值，其顶点为 1 或者 2，随便取一个即可，我们这里取 1。即此时又找到一条边：`3→1` 。

     - 第 3 步：从 1 开始，继续更新`low_cost[]`数组：因与 1 邻接的点都被放入最小生成树中，故不更新，直接在`low_cost[]`中找到最小值，其顶点为 2，即此时又找到一条边：`0→2`。

     - 第 4 步：从 2 开始，继续更新`low_cost[]`数组：2 与 4 邻接，因`2→4`比`low_cost[4]`小，故更新`low_cost[4]`为 1。在`low_cost[]`中找到最小值，其顶点为 4，即此时又找到一条边：`2→4`。

     - 第 5 步：最小生成树完成，停止。


4. **具体实现**

   - 辅助变量及详细描述：

     ```c++
     private:
         int **_graph;   //邻接矩阵
         char *_names;   //各个顶点的名称
         int* _index;    //通过各个顶点的名称作为索引查找该点的位置
         int _n;         //顶点个数
         int* _cost;     //存放开销的数组
         int* _path;     //存放每个点的最临近点的数组
         int _sum;       //总开销
     ```

   - 初始化：

     首先读入顶点和顶点的名称，这个时候初始化邻接矩阵，每个顶点之间的路径权值为无穷大。用辅助数组`_index`来作为顶点名和顶点序号之间的索引，这样在每次通过顶点名字查找顶点序号时无需搜索就可直接访问。

     ```c++
         void createGraph(void){
             cout << "请输入顶点的个数：" << endl;
             cin >> _n;
             _graph = new int*[_n]();
             _names = new char[_n]();
             _index = new int[255]();
             _cost = new int[_n]();
             _path = new int[2 * (_n - 1)]();
             _sum = 0;
             memset(_index, -1, 255 * sizeof(int));
             cout << "请依次输入各顶点的名称：" << endl;
             for (int i = 0; i < _n; i++) {
                 cin >> _names[i];
                 _index[_names[i]] = i;
                 _graph[i] = new int[_n]();
                 for (int j = 0; j < _n; j++) {
                     _graph[i][j] = INFINITE;
                 }
             }
         }
     //=============================================================
         void addEdge(void){
             while (1) {
                 cout << "请输入两个顶点及边：" << endl;
                 char vertex_1, vertex_2;
                 int weight;
                 cin >> vertex_1 >> vertex_2 >> weight;
                 if(vertex_1 == '?') {
                     break;
                 }
                 _graph[_index[vertex_1]][_index[vertex_2]] = weight;
                 _graph[_index[vertex_2]][_index[vertex_1]] = weight;
             }
         }
     ```

   - 建立最小生成树

     首先建立方法内的辅助数组，用于记录当前已经连通图的可访问点的权值和目前顶点的访问情况，然后将起始顶点的邻接顶点放入可访问的数组中，将其权值加入存放开销的数组，同时默认所有点的最临近点为初始顶点（如果通向某点的路径最小权值一直没有更新的话，则连接该点的路径就是访问初始点的时候的路径，即其最临近点就是初始点）

     ```c++
             int *cost = new int[_n]();          //辅助数组，存放可访问点的开销情况
             int *if_visited = new int[_n]();    //辅助数组，看某点是否已经被访问过
             for (int i = 0; i < _n; i++) {
                 //将起始顶点的邻接顶点放入可访问的数组中，将其权值加入存放开销的数组
                 cost[i] = _graph[_index[start_vertex]][i];
                 _path[i] = _index[start_vertex];
                 _cost[i] = _graph[_index[start_vertex]][i];
             }
             if_visited[_index[start_vertex]] = 1;
     ```

     对于有n个顶点的图，其最小生成树有n-1条边，故当确定初始点时需循环n-2次以便找到剩下的n-1个点。对于每一次循环添加进最小生成树的顶点，遍历其可以访问的顶点，如果存在可以访问、且连接的边的权值比之前访问时的权值要低，则更新访问该点的边的权值，同时更新该顶点的最临近顶点。当一轮更新完成时，`cost`数组里储存的是当前当前访问某顶点所需的最小权值，`_path`数组里储存的是当前所有顶点的最临近点（初始顶点的最临近点是其本身）。

     ```c++
             int low_cost = INFINITE;
             int low_cost_index = 0;
             for (int i = 0; i < _n - 1; i++) {
                 low_cost = INFINITE;
                 //找到可访问的顶点中权值最小的点
                 for (int j = 0; j < _n; j++) {
                     if(if_visited[j] != 1 && cost[j] < low_cost){
                         low_cost = cost[j];
                         low_cost_index = j;
                     }
                 }
                 //标记已访问的顶点，累加开销
                 if_visited[low_cost_index] = 1;
                 _sum += low_cost;
                 //更新可访问点的权值，每发生一次更新，就将新的最临近点加入_path
                 for (int j = 0; j < _n; j++) {
                     if (if_visited[j] != 1 && _graph[low_cost_index][j] < cost[j]) {
                         cost[j] = _graph[low_cost_index][j];
                         _path[j] = low_cost_index;
                         _cost[j] = cost[j];
                     }
                 }
             }
     ```

5. **运行示例**

6. **鲁棒性测试**

   1. 输入的命令不存在
      - 测试用例：向系统中输入的命令不存在
      - 预期结果：操作之后系统提示输入非法，程序正常运行不崩溃。
      - 测试结果：
   2. 创建电网顶点时输入的顶点数量小于2
      - 测试用例：创建电网顶点时输入的顶点数量为1、0或负数
      - 预期结果：操作之后系统提示输入的顶点数量错误，提示重新输入，程序正常运行不崩溃。
      - 测试结果：
   3. 添加边时输入不存的顶点
      - 测试用例：执行添加边的操作时，向系统中输入的顶点不存在
      - 预期结果：操作之后系统提示输入的顶点不存在，添加边失败，仍可重新继续添加其他正确的边，程序正常运行不崩溃。
      - 测试结果：

