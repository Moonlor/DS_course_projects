# 数据结构课程设计 项目说明文档

>  #### 八种排序算法的比较
>
>  李坤
>
>  1553321





1. **项目介绍**

   - 冒泡排序、选择排序、直接插入排序、希尔排序、快速排序、堆排序、归并排序、基数排序是常见的八种排序方式，实现各有所异，速度也有所差别。

   - 随机函数产生n个随机数，用冒泡排序、选择排序、直接插入排序、希尔排序、快速排序、堆排序、归并排序、基数排序的排序方法排序，并统计每种排序所花费的排序时间和交换次数。其中，随机数的个数由用户定义，系统产生随机数。并且显示他们的比较次数。

     ​

2. **整体描述**

   - 本项目是对八种常见排序算法的实现和对比。用控制台选项的选择方式完成下列功能：输入产生的随机数数量、选取八种不同的排序算法进行排序并进行排序时间比较。

   - 运行环境：

     exe可执行文件：带有图形驱动的windows平台

     经过测试，源码也可在Unix平台（如MacOS）上正常编译并运行

   - 代码托管平台：Github




-----------

###冒泡排序

1. **设计**

   - **算法流程**：冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。　　![img](http://images2015.cnblogs.com/blog/1024555/201611/1024555-20161126001352300-2027386210.png)

   - **优化**

     在冒泡排序的过程中，如果某一趟执行完毕，没有做任何一次交换操作，比如数组[5,4,1,2,3]，执行了两次冒泡，也就是两次外循环之后，分别将5和4调整到最终位置[1,2,3,4,5]。此时，再执行第三次循环后，一次交换都没有做，这就说明剩下的序列已经是有序的，排序操作也就可以完成了。

2. **具体实现**

   - 用`flag`标记在一次循环中是否发生了元素交换，当没有交换时表明数串已经有序。

     ```c++
         int *sort(int *numbers, int count){
             _result = new int[count]();
             for (int i = 0; i < count; i++) {
                 _result[i] = numbers[i];
             }
             unsigned int swap_times = 0;
             clock_t start_time=clock();         //计时开始
             {
                 for (int i = 0; i < count - 1; i++) {
                     bool flag = true;
                     for (int j = 0; j < count - i - 1; j++) {
                         //当发生后一个元素小于前一个元素的情况，将后一个元素前移，与前面一个元素交换
                         if (_result[j] > _result[j+1]) {
                             int temp = _result[j + 1];
                             _result[j + 1] = _result[j];
                             _result[j] = temp;
                             swap_times++;
                             flag = false;
                         }
                     }
                     if (flag) break;
                 }
             }
             clock_t end_time=clock();   //计时结束
             cout << "冒泡排序所用时间：\t\t" 
                  << static_cast<double>(end_time-start_time)/CLOCKS_PER_SEC*1000 
                  << "ms" << endl;
             cout << "冒泡排序交换次数：\t\t" << swap_times << endl;
             return _result;
         }
     ```

   - **运行示例**


-----------------

### 选择排序

1. **设计**

   - **算法流程**：选择排序的基本思想是每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止，最终达到完全有序。简单选择排序是不稳定排序。

   - **时间复杂度**：O(n^2)

   - **优化**

     在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。其实我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。我们可以通过设置一个变量min，每一次比较仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。

2. **具体实现**

   - 每一次循环都从无序序列中找出当前序列内的最小元素，并放入有序序列的末尾，当进行了n-1次查找时，则序列已经重新排布完成。

     ```c++
         int *sort(int *numbers, int count){
             _result = new int[count]();
             for (int i = 0; i < count; i++) {
                 _result[i] = numbers[i];
             }
             unsigned int swap_times = 0;
             clock_t start_time=clock();       //计时开始
             {
               //每次从无序序列中找到一个最小元素加入有序序列的最后一个元素
                 for (int i = 0; i < count - 1; i++) {
                     for (int j = i; j < count; j++) {
                         if(_result[j] < _result[i]){
                             int temp = _result[j];
                             _result[j] = _result[i];
                             _result[i] = temp;
                             swap_times++;
                         }
                     }
                 }
             }
             clock_t end_time=clock();      //计时结束
             cout << "选择排序所用时间：\t\t" << static_cast<double>(end_time-start_time)/CLOCKS_PER_SEC*1000 << "ms" << endl;
             cout << "选择排序交换次数：\t\t" << swap_times << endl;
             return _result;
         }
     ```

   - **运行示例**

     ​

-----------

### 直接插入排序

1. **设计**

   - **算法流程**：直接插入排序的基本思想是，每一步将一个待排序的元素，插入到前面已经排好序的有序序列中去，直到插完所有元素为止，最终达到完全有序。　

   - **时间复杂度**：O(n^2)　![img](http://images2015.cnblogs.com/blog/1024555/201611/1024555-20161126000335346-416319390.png)

   - **优化**

     利用直接插入排序的基本思想，在一个有序序列中查找一个插入位置，使用二分查找可以减少元素比较次数，提高效率。

2. **具体实现**

   - 从第一个元素开始，从前向后搜索，当前元素之前的元素为已排序元素序列，之后为未排序元素序列。

     ```c++
         int *sort(int *numbers, int count){
             _result = new int[count]();
             for (int i = 0; i < count; i++) {
                 _result[i] = numbers[i];
             }
             unsigned int swap_times = 0;
             clock_t start_time=clock();     //计时开始
             {
                 for (int i = 1; i < count; i++) {
                     //当未排序元素的第一个元素小于已排序元素序列中的最后一个元素
                     if(_result[i - 1] > _result[i]){
                         int temp = _result[i];  //将未排序元素的第一个元素选为目标插入元素
                         int j = i - 1;
             //从已排序序列的最后一个元素开始向前搜索，将已排序元素一一向后移位，直至可以插入目标元素
                         for (; j >= 0 && _result[j] > temp; j--) {
                             _result[j + 1] = _result[j];
                             swap_times++;
                         }
                         _result[j + 1] = temp;
                         swap_times++;
                     }
                 }
             }
             clock_t end_time=clock();       //计时结束
             cout << "直接插入排序所用时间：\t\t" 
                  << static_cast<double>(end_time-start_time)/CLOCKS_PER_SEC*1000 
                  << "ms" << endl;
             cout << "直接插入排序交换次数：\t\t" << swap_times / 2 << endl;
             return _result;
         }
     ```

   - **运行示例**



------

### 希尔排序

1. **设计**

   - **算法流程**：希尔排序，也称递减增量排序算法。算法最开始以一定的步长进行排序，然后会继续以更小的步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为直接插入排序，这就保证了数据一定会被全部排序。

   - **时间复杂度**： 

     希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长 5 进行了排序然后再以步长 3 进行排序，那么该数列不仅是以步长 3 有序，而且是以步长 5 有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。

     | 步长序列      | 最坏情况下复杂度     |
     | --------- | ------------ |
     | n/(2^i)   | O(n^2)       |
     | 2^i - 1   | O(n^(2/3))   |
     | 2^i * 3^i | O(nlog^2(n)) |

   - **算法步骤举例**：

     假设有这样一组数 {13, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10}，如果我们以步长为 5 开始进行排序：

     ```
     13 14 94 33 82
     25 59 94 65 23
     45 27 73 25 39
     10
     ```

     然后我们对**每列**进行排序：

     ```
     10 14 73 25 23
     13 27 94 33 39
     25 59 94 65 82
     45

     ```

     将上述四行数字，依序接在一起时我们得到：{10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45}，然后再以 3 为步长：

     ```
     10 14 73
     25 23 13
     27 94 33
     39 25 59
     94 65 82
     45
     ```

     排序之后变为：

     ```
     10 14 13
     25 23 33
     27 25 59
     39 65 73
     45 94 82
     94
     ```

     最后以 1 为步长进行排序（此时就是简单的插入排序了）。

2. **具体实现**

   - 本算法采用由Knuth提出的h序列，即`gap = (gap - 1)/3`作为序列。

     ```c++
         int *sort(int *numbers, int count){
             _result = new int[count]();
             for (int i = 0; i < count; i++) {
                 _result[i] = numbers[i];
             }
             unsigned int swap_times = 0;
             clock_t start_time=clock();     //计时开始
             {
                 int gap = 1;
                 //以gap = 1的最终值进行反推，求出gap增量序列的最大值
                 while (gap <= count / 3) {
                     gap = gap * 3 + 1;
                 }
                 while (gap > 0) {
                     for (int i = gap; i < count; i++) {
                         //按gap将无序序列分为count/gap个组，对每个组进行插入排序
                         if(_result[i - gap] > _result[i]){
                             //将此时的较小值保存
                             int temp = _result[i];
                             int j = i - gap;
                             //从较大值开始，将其一个一个后移，直到找到合适的插入位置
                             for (; j >= 0 && _result[j] > temp; j -= gap) {
                                 _result[j + gap] = _result[j];
                                 swap_times++;
                             }
                             //当前值比保存值还小时，则证明上一个位置是正确位置，将之前保存的值插入
                             _result[j + gap] = temp;
                             swap_times++;
                         }
                     }
                     //得到下一个gap序列值
                     gap = (gap - 1) / 3;
                 }
             }
             clock_t end_time=clock();       //计时结束
             cout << "希尔插入排序所用时间：\t\t" << static_cast<double>(end_time-start_time)/CLOCKS_PER_SEC*1000 << "ms" << endl;
             cout << "希尔插入排序交换次数：\t\t" << swap_times / 2 << endl;
             return _result;
         }
     ```

   - **运行示例**





------

### 快速排序

1. **设计**

   - **算法流程**：快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

   - **时间复杂度**：O(n^2)　 

   - **优化**

     1. 在快排的过程中，每一次我们要取一个元素作为枢纽值，以这个数字来将序列划分为两部分。在此我们采用三数取中法，也就是取左端、中间、右端三个数，然后进行排序，将中间数作为枢纽值。

        ![img](http://images2015.cnblogs.com/blog/1024555/201701/1024555-20170108124741566-1283178705.png)

     2. 根据枢纽值进行分割

        ![img](http://images2015.cnblogs.com/blog/1024555/201701/1024555-20170108162758159-793891242.png)

        ![img](http://images2015.cnblogs.com/blog/1024555/201701/1024555-20170108162855675-777137351.png)

2. **具体实现**

   - 从第一个元素开始，从前向后搜索，当前元素之前的元素为已排序元素序列，之后为未排序元素序列。

     ```c++
         void quickSort(int *target, int left_index, int right_index){
             //当左右索引重合时，递归结束，序列已经有序
             if(left_index < right_index){
                 int key_value = target[left_index];     //主元
                 int low_index = left_index;             //左起点
                 int high_index = right_index;           //右起点
                 //此时主元素所在的位置为空位
                 while (low_index < high_index) {
                     //从右边开始搜索，直到发现比主元小的元素
                     while (low_index < high_index && key_value < target[high_index]) {
                         high_index--;
                     }
                     //将找到的较小元素放入到空出来的位置，此时其原位置为空，可被放置一个较大元素
                     target[low_index] = target[high_index];
                     _swap_times++;
                     //从左边继续搜索，直到发现比主元大的元素
                     while (low_index < high_index && key_value > target[low_index]) {
                         low_index++;
                     }
                     //将找到的较大元素放入刚刚空出来的位置，此时其原位置为空，可被放置一个较小元素
                     target[high_index] = target[low_index];
                     _swap_times++;
                 }
                 //将主元素填入交换完成后剩下的空位，此时主元素左边的所有元素均小于主元素，右边均大于主元素
                 target[low_index] = key_value;
                 _swap_times++;
                 //分别对左右序列进行递归
                 quickSort(target, left_index, low_index - 1);
                 quickSort(target, low_index + 1, right_index);
             }
         }
         
         int *sort(int *numbers, int count){
             _result = new int[count]();
             for (int i = 0; i < count; i++) {
                 _result[i] = numbers[i];
             }
             clock_t start_time=clock();     //开始计时
             {
                 //调用递归函数进行快速排序，初始下待排序数组左下标为0，右下标为数组元素个数-1
                 quickSort(_result, 0, count - 1);
             }
             clock_t end_time=clock();       //计时结束
             cout << "快速排序所用时间：\t\t" 
                  << static_cast<double>(end_time-start_time)/CLOCKS_PER_SEC*1000 
                  << "ms" << endl;
             cout << "快速排序交换次数：\t\t" << _swap_times << endl;
             return _result;
         }
     ```

   - **运行示例**





6. **算法正确性检验**
   1. 从1到10，检查算法是否能输出正确的结果
      - 测试用例：向系统中分别输入1～10，检查算法是否能正确输出结果
      - 预期结果：操作之后算法能正确输出结果，程序正常运行不崩溃。
      - 测试结果：
   2. 初始化时输入非法操作数
      - 测试用例：初始化时向系统中输入负数或0
      - 预期结果：程序给出输入错误的提示并正常退出，运行期间不崩溃
      - 测试结果：