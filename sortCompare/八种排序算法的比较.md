# 数据结构课程设计 项目说明文档

>  #### N皇后问题
>
>  李坤
>
>  1553321





1. **项目介绍**

   - 冒泡排序、选择排序、直接插入排序、希尔排序、快速排序、堆排序、归并排序、基数排序是常见的八种排序方式，实现各有所异，速度也有所差别。

   - 随机函数产生n个随机数，用冒泡排序、选择排序、直接插入排序、希尔排序、快速排序、堆排序、归并排序、基数排序的排序方法排序，并统计每种排序所花费的排序时间和交换次数。其中，随机数的个数由用户定义，系统产生随机数。并且显示他们的比较次数。

     ​

2. **整体描述**

   - 本项目是对八种常见排序算法的实现和对比。用控制台选项的选择方式完成下列功能：输入产生的随机数数量、选取八种不同的排序算法进行排序并进行排序时间比较。

   - 运行环境：

     exe可执行文件：带有图形驱动的windows平台

     经过测试，源码也可在Unix平台（如MacOS）上正常编译并运行

   - 代码托管平台：Github




-----------

###冒泡排序

1. **设计**

   - **算法流程**：冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。　　![img](http://images2015.cnblogs.com/blog/1024555/201611/1024555-20161126001352300-2027386210.png)

   - **优化**

     在冒泡排序的过程中，如果某一趟执行完毕，没有做任何一次交换操作，比如数组[5,4,1,2,3]，执行了两次冒泡，也就是两次外循环之后，分别将5和4调整到最终位置[1,2,3,4,5]。此时，再执行第三次循环后，一次交换都没有做，这就说明剩下的序列已经是有序的，排序操作也就可以完成了。

2. **具体实现**

   - 初始化保存皇后位置的数组和三个辅助数组，分别用来判断皇后在列方向和对角线方向是否合法

     ```c++
         int* q = new int[n]();      //第n个皇后所在的列坐标
         int* v = new int[n]();      //辅助数组，用来标记第i列是否有已经有皇后占用
         int* l = new int[2 * n]();  //辅助数组，用来标记第i条左斜线是否已经有皇后占用
         int* r = new int[2 * n]();  //辅助数组，用来标记第i条右斜线是否已经有皇后占用
         
         recall(0, n, q, v, l, r);
     ```

   - **运行示例**






6. **算法正确性检验**
   1. 从1到10，检查算法是否能输出正确的结果
      - 测试用例：向系统中分别输入1～10，检查算法是否能正确输出结果
      - 预期结果：操作之后算法能正确输出结果，程序正常运行不崩溃。
      - 测试结果：
   2. 初始化时输入非法操作数
      - 测试用例：初始化时向系统中输入负数或0
      - 预期结果：程序给出输入错误的提示并正常退出，运行期间不崩溃
      - 测试结果：